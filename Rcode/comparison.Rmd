---
title: "comparison"
author: "zhuofan"
date: '2022-07-05'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## data generation

```{r}
generateA = function(n, a, k) {
  flag = 0
  
  while(flag == 0) {
    # first sample generate features
    nones = rpois(1, a)
    while(nones == 0) nones = rpois(1, a)
    A = matrix(rep(1, nones), nrow = 1)
    
    # subsequent samples
    for(i in 2 : n) {
      # update existing features
      A = rbind(A, runif(ncol(A)) < colSums(A) / i)
      # generate new features
      nones = rpois(1, a / i)
      if(nones != 0) {
        A = cbind(A, matrix(0, nrow(A), nones))
        A[i, (ncol(A) - nones) : ncol(A)] = 1
      }
    }
    
    # accepting criteria
    if(ncol(A) == k) flag = 1
  }
  return(A)
}

library(simFrame)


generatedata_overlap <- function(seednum){
d <- c(15,200,15)
set.seed(2022)
y <- array(NA,dim = d)
r <- 3
m <- 1
rho <- 0.3
nac<-NAControl(NArate=0.5)
gamma <- c(rho/2,1-rho,rho/2)
mu <- 0
sigma2 <- 1
v <- 7
c1o <- generateA(d[1],m,r)
#c2o <- matrix(rbinom(d[2]*r,1,rho),nrow = d[2])
c2o = matrix(as.numeric(runif(d[2] * r) < rho), d[2], r)
#c3o <- matrix(sample(c(-1,0,1),d[3]*r,TRUE,gamma),nrow = d[3])
c3o = matrix(as.numeric(runif(d[3] * r) < rho), d[3], r)
c3o[c3o == 1] = 2 * (runif(sum(c3o == 1)) < 0.5) - 1
l1 <- seq(6.0,6+0.5*(r-1),length.out = r)
#l2 <- t(seq(2.0,4.5,by = 0.5)%o%rep(1,d[3]))
l2 <- l1

lambda1 <- matrix(rep(l1,d[3]),nrow = d[3],byrow = TRUE)
lambda2 <- lambda1
#generate b1,b2
#b1 <- rnorm(d[2]*d[3])
b1 <- log(0.1)
#b2 <- rnorm(d[2]*d[3])
b2 <- b1
b1m <- matrix(b1,nrow = d[2],ncol = d[3])
b2m <- b1m

#generate z & y
theta1 <- array(0,dim =d)
theta2 <- array(0,dim =d)
for(i in 1:r){
  theta1 <- theta1+l1[i]*c1o[,i]%o%c2o[,i]%o%(c3o==-1)[,i]
  theta2 <- theta2+l2[i]*c1o[,i]%o%c2o[,i]%o%(c3o==1)[,i]
}
theta1 <- theta1+b1
theta2 <- theta2+b2

theta1 <- exp(theta1)
theta2 <- exp(theta2)
set.seed(seednum)
# generate latent ternary indicator z
U0 = array(runif(d[1]*d[2]*d[3]),dim = d)

z0 = (U0 > (theta1 + 1) / (theta1 + theta2 + 1)) - (U0 < theta1 / (theta1 + theta2 + 1))

#y[z0==1] <- rnorm(sum(z0==1),mu+10,5)
y[z0==1] <- runif(sum(z0==1),mu,mu+5)

y[z0==0] <- rnorm(sum(z0==0),mu,sigma2)

#y[z0==-1] <- rnorm(sum(z0==-1),mu-10,5)
y[z0==-1] <- runif(sum(z0==-1),mu-5,mu)
yd <- data.frame(as.vector(y))
yna <- setNA(yd,nac)
yna <- yna[,1]
yna <- array(yna,dim = d)
return(list(y,yna,c1o,c2o,c3o))
}

generate_nonoverlap <- function(seednum){
  set.seed(2)
  d <- c(15,200,15)
  y <- array(NA,dim = d)
  r <- 3
  rho <- 0.3
  gamma <- c(rho/2,1-rho,rho/2)
  
  mu <- 0
  sigma2 <- 1
  v <- 7
  
  # generate feature <-> latent feature matrix C (ternary): number of features p = 50
  #pi <- rdirichlet(1,c(2,2,6))
  c1o <- t(rmultinom(d[1],1,c(3,3,4)))
  #c2o <- matrix(rbinom(d[2]*r,1,rho),nrow = d[2])
  c2o <- t(rmultinom(d[2],1,c(3,3,4)))
  #c3o <- matrix(sample(c(-1,0,1),d[3]*r,TRUE,gamma),nrow = d[3])
  c3o <- t(rmultinom(d[3],1,c(3,3,4)))
  c3o[c3o == 1] = 2 * (runif(sum(c3o == 1)) < 0.5) - 1
  l1 <- seq(6.0,6+0.5*(r-1),length.out = r)
  #l2 <- t(seq(2.0,4.5,by = 0.5)%o%rep(1,d[3]))
  l2 <- l1
  
  lambda1 <- matrix(rep(l1,d[3]),nrow = d[3],byrow = TRUE)
  lambda2 <- lambda1
  #generate b1,b2
  #b1 <- rnorm(d[2]*d[3])
  b1 <- log(0.1)
  #b2 <- rnorm(d[2]*d[3])
  b2 <- b1
  b1m <- matrix(b1,nrow = d[2],ncol = d[3])
  b2m <- b1m
  
  #generate z & y
  theta1 <- array(0,dim =d)
  theta2 <- array(0,dim =d)
  for(i in 1:r){
    theta1 <- theta1+l1[i]*c1o[,i]%o%c2o[,i]%o%(c3o==-1)[,i]
    theta2 <- theta2+l2[i]*c1o[,i]%o%c2o[,i]%o%(c3o==1)[,i]
  }
  theta1 <- theta1+b1
  theta2 <- theta2+b2
  
  theta1 <- exp(theta1)
  theta2 <- exp(theta2)
  set.seed(seednum)
  # generate latent ternary indicator z
  U0 = array(runif(d[1]*d[2]*d[3]),dim = d)
  
  z0 = (U0 > (theta1 + 1) / (theta1 + theta2 + 1)) - (U0 < theta1 / (theta1 + theta2 + 1))
  
  #y[z0==1] <- rnorm(sum(z0==1),mu+10,5)
  y[z0==1] <- runif(sum(z0==1),mu,mu+5)
  
  y[z0==0] <- rnorm(sum(z0==0),mu,sigma2)
  
  #y[z0==-1] <- rnorm(sum(z0==-1),mu-10,5)
  y[z0==-1] <- runif(sum(z0==-1),mu-5,mu)
  return(list(y,c1o,c2o,c3o))
}

generatedata_na <- function(seednum,nac){
d <- c(15,200,15)
set.seed(2022)
y <- array(NA,dim = d)
r <- 3
m <- 1
rho <- 0.3
gamma <- c(rho/2,1-rho,rho/2)
mu <- 0
sigma2 <- 1
v <- 7
c1o <- generateA(d[1],m,r)
#c2o <- matrix(rbinom(d[2]*r,1,rho),nrow = d[2])
c2o = matrix(as.numeric(runif(d[2] * r) < rho), d[2], r)
#c3o <- matrix(sample(c(-1,0,1),d[3]*r,TRUE,gamma),nrow = d[3])
c3o = matrix(as.numeric(runif(d[3] * r) < rho), d[3], r)
c3o[c3o == 1] = 2 * (runif(sum(c3o == 1)) < 0.5) - 1
l1 <- seq(6.0,6+0.5*(r-1),length.out = r)
#l2 <- t(seq(2.0,4.5,by = 0.5)%o%rep(1,d[3]))
l2 <- l1

lambda1 <- matrix(rep(l1,d[3]),nrow = d[3],byrow = TRUE)
lambda2 <- lambda1
#generate b1,b2
#b1 <- rnorm(d[2]*d[3])
b1 <- log(0.1)
#b2 <- rnorm(d[2]*d[3])
b2 <- b1
b1m <- matrix(b1,nrow = d[2],ncol = d[3])
b2m <- b1m

#generate z & y
theta1 <- array(0,dim =d)
theta2 <- array(0,dim =d)
for(i in 1:r){
  theta1 <- theta1+l1[i]*c1o[,i]%o%c2o[,i]%o%(c3o==-1)[,i]
  theta2 <- theta2+l2[i]*c1o[,i]%o%c2o[,i]%o%(c3o==1)[,i]
}
theta1 <- theta1+b1
theta2 <- theta2+b2

theta1 <- exp(theta1)
theta2 <- exp(theta2)
set.seed(seednum)
# generate latent ternary indicator z
U0 = array(runif(d[1]*d[2]*d[3]),dim = d)

z0 = (U0 > (theta1 + 1) / (theta1 + theta2 + 1)) - (U0 < theta1 / (theta1 + theta2 + 1))

#y[z0==1] <- rnorm(sum(z0==1),mu+10,5)
y[z0==1] <- runif(sum(z0==1),mu,mu+5)

y[z0==0] <- rnorm(sum(z0==0),mu,sigma2)

#y[z0==-1] <- rnorm(sum(z0==-1),mu-10,5)
y[z0==-1] <- runif(sum(z0==-1),mu-5,mu)
yna <- y
#nac <- sample(1:(d[1]*d[2]),0.5*d[1]*d[2])
for (g in 1:d[3]) {
  #for (t in 1:d[1]) {
    yna[,,g][nac] <- NA
  #}
}
return(list(y,yna,c1o,c2o,c3o))
}
```

## evluation

```{r}
library(e1071)
min_ham = function(A, B) {
  ## list all permutations
  permutation = e1071::permutations(ncol(A))
  
  DHamming = rep(NA, nrow(permutation))
  for(l in 1 : nrow(permutation)) {
    NB = as.vector(B[, permutation[l, ]])
    DHamming[l] = sum(abs(as.vector(A) - NB))
  }
  return(min(DHamming))
}

modev <- function(x){
return(as.numeric(names(table(x))[table(x) == max(table(x))]))}
tomembershipmatrix <- function(z){
  d = length(z)
  Z = list()
  for (i in 1:d){
    zi = z[[i]]
    pi = length(zi)
    ri = length(unique(zi))
    Zi = matrix(0, pi, ri)
    for (k in 1:ri){
      zi.subset = which(zi==k)
      Zi[zi.subset,k] = 1
    }
    Z = c(Z, list(Zi))
  }
  return(Z)
}
perE = function(A, B) {
  ## list all permutations
  permutation = e1071::permutations(ncol(A))
  
  DHamming = rep(NA, nrow(permutation))
  for(l in 1 : nrow(permutation)) {
    NB = as.vector(B[, permutation[l, ]])
    DHamming[l] = sum(abs(as.vector(A) - NB))
  }
  
  return(permutation[which.min(DHamming), ])
}

```

# comparison

```{r}
library("doParallel")   
library("foreach") 
cl<- makeCluster(8) 
registerDoParallel(cl) 
```

## BMWC

```{r}
bayes_multi <- function(y,c1o,c2o,c3o){
set.seed(1)
{
  c1track <- list()
  c2track <- list()
  c3track <- list()
  al=1;bl=3;av=1;bv=10;am=1;bm=1;sigmal=1;mub=-2
  ;sigmab=1;arho=1;brho=1;psi_1=5;psi0=20;psi1=5;as=1;bs=1;sigmamu=1;
 
  #//dimension
  d=dim(y);
  
 #//class number
  r=1;
  c1 = matrix(as.numeric(runif(d[1] * r) < 0.5), d[1], r)
  c2 =matrix(as.numeric(runif(d[2] * r) < 0.5), d[2], r)
  c3 = matrix(as.numeric(runif(d[3] * r) < 0.5), d[3], r)
  lambda1 <- matrix(rgamma(d[3]*r, al, 1/bl), d[3],r)
  lambda2 <- lambda1
  #//paramters
  mu1 <- rep(0,d[1])
  mu2 <- rep(0,d[2])
  mu3 <- rep(0,d[3])
  sigma2 <- rep(1,d[1])
  v1 <- 5*sigma2
  v2 <- v1
  #b1 <- matrix(rnorm(d[2]*d[3]),nrow = d[2],ncol = d[3])
  b1 <- matrix(-2,nrow = d[2],ncol = d[3])
  b2 <-b1
  m=3;rho=0.3;g=1;
  
  #vec gamma(3,fill::randu);
  gamma <- c(rho/2,1-rho,rho/2)
  #z <- z0
  z <- array(0,dim = d)
  #z[which(is.na(y))] <- NA
}
  #//MCMC update
  pb <- progress_bar$new(format = "  complete [:bar] :percent eta: :eta",
                       total = 5000, clear = FALSE, width= 60)
  for(it in 1:5000){
    #ztrack[[it]] <- z
    
    
    z <- update_z(c1, c2, c3, lambda1, lambda2, d, z, b1, b2, v1, v2, av, bv, y, mu1, mu2, mu3, sigma2);
    v1 <- update_v1(z,y,mu1,mu2,mu3,v1,v2,d,av,bv,sigma2)
    v2 <- update_v2(z,y,mu1,mu2,mu3,v1,v2,d,av,bv,sigma2)
    li1 <- update_c1(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,gamma, m,g,rho,al,bl)
    c1 <- li1[[1]]
    c2 <- li1[[2]]
    c3 <- li1[[3]]
    lambda1 <- li1[[4]]
    lambda2 <- li1[[5]]
    r <- ncol(c1)
    c2 <- update_c2(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,rho);
    li2 <-  update_c3(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,gamma,sigmal,al,bl)
    c3 <-li2[[1]]
    lambda1 <- li2[[2]]
    lambda2 <- li2[[3]]
    
    m <- rgamma(1,am+r,bm+har(d[1]))
    #//update $\rho$
    rho <-  rbeta(1,arho+sum(c2),brho+d[2]*r-sum(c2))
    #//update $\gamma$
    probs <- c(psi_1+sum(c3==-1),psi0+sum(c3==0),psi1+sum(c3==1))
    gamma <- rdirichlet(1,probs)
    li5 <- update_bunit(d,mub,sigmab,b1,b2,c1,c2,c3,lambda1,lambda2,z)
    b1 <- li5[[1]]
    b2 <- li5[[2]]
    sigma2 <- update_sigma2(z,y,mu1,mu2,mu3,v1,v2)
    mu1 <- update_mu1(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    mu2 <- update_mu2(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    mu3 <- update_mu3(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    c1track[[it]] <- c1
    c2track[[it]] <- c2
    c3track[[it]] <- c3
    pb$tick()
    Sys.sleep(1/100)
  }
  c1track <- c1track[2501:5000]
  c2track <- c2track[2501:5000]
  c3track <- c3track[2501:5000]
  rvec <- unlist(lapply(c1track, function(x) return(ncol(x))))
  rp <- as.numeric(names(table(rvec))[table(rvec) == max(table(rvec))])
  c1track <- c1track[which(rvec==rp)]
  c2track <- c2track[which(rvec==rp)]
  c3track <- c3track[which(rvec==rp)]
  c1p <- matrix(unlist(c1track),nrow = d[1]*rp)
  c2p <- matrix(unlist(c2track),nrow = d[2]*rp)
  c3p <- matrix(unlist(c3track),nrow = d[3]*rp)
  c1p <- matrix(rowMeans(c1p),nrow=d[1])
  c2p <- matrix(rowMeans(c2p),nrow=d[2])
  c3p <- matrix(rowMeans(c3p),nrow=d[3])
return(c(min_ham(c1o, c1p),min_ham(c2o, c2p),min_ham(c3o, c3p)))
}

bayes_multi_n <- function(y,c1o,c2o,c3o){
set.seed(1)
{
  c1track <- list()
  c2track <- list()
  c3track <- list()
  al=1;bl=3;av=1;bv=10;am=10;bm=1;sigmal=1;mub=-2
  ;sigmab=1;arho=1;brho=1;psi_1=3;psi0=10;psi1=3;as=1;bs=1;sigmamu=1;
 
  #//dimension
  d=dim(y);
  
 #//class number
  r=1;
  c1 = matrix(as.numeric(runif(d[1] * r) < 0.5), d[1], r)
  c2 =matrix(as.numeric(runif(d[2] * r) < 0.5), d[2], r)
  c3 = matrix(as.numeric(runif(d[3] * r) < 0.5), d[3], r)
  lambda1 <- matrix(rgamma(d[3]*r, al, 1/bl), d[3],r)
  lambda2 <- lambda1
  #//paramters
  mu1 <- rep(0,d[1])
  mu2 <- rep(0,d[2])
  mu3 <- rep(0,d[3])
  sigma2 <- rep(1,d[1])
  v1 <- 5*sigma2
  v2 <- v1
  #b1 <- matrix(rnorm(d[2]*d[3]),nrow = d[2],ncol = d[3])
  b1 <- matrix(-2,nrow = d[2],ncol = d[3])
  b2 <-b1
  m=3;rho=0.3;g=1;
  
  #vec gamma(3,fill::randu);
  gamma <- c(rho/2,1-rho,rho/2)
  #z <- z0
  z <- array(0,dim = d)
  #z[which(is.na(y))] <- NA
}
  #//MCMC update
  pb <- progress_bar$new(format = "  complete [:bar] :percent eta: :eta",
                       total = 5000, clear = FALSE, width= 60)
  for(it in 1:5000){
    #ztrack[[it]] <- z
    
    
    z <- update_z(c1, c2, c3, lambda1, lambda2, d, z, b1, b2, v1, v2, av, bv, y, mu1, mu2, mu3, sigma2);
    v1 <- update_v1(z,y,mu1,mu2,mu3,v1,v2,d,av,bv,sigma2)
    v2 <- update_v2(z,y,mu1,mu2,mu3,v1,v2,d,av,bv,sigma2)
    li1 <- update_c1(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,gamma, m,g,rho,al,bl)
    c1 <- li1[[1]]
    c2 <- li1[[2]]
    c3 <- li1[[3]]
    lambda1 <- li1[[4]]
    lambda2 <- li1[[5]]
    r <- ncol(c1)
    c2 <- update_c2(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,rho);
    li2 <-  update_c3(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,gamma,sigmal,al,bl)
    c3 <-li2[[1]]
    lambda1 <- li2[[2]]
    lambda2 <- li2[[3]]
    
    m <- rgamma(1,am+r,bm+har(d[1]))
    #//update $\rho$
    rho <-  rbeta(1,arho+sum(c2),brho+d[2]*r-sum(c2))
    #//update $\gamma$
    probs <- c(psi_1+sum(c3==-1),psi0+sum(c3==0),psi1+sum(c3==1))
    gamma <- rdirichlet(1,probs)
    li5 <- update_bunit(d,mub,sigmab,b1,b2,c1,c2,c3,lambda1,lambda2,z)
    b1 <- li5[[1]]
    b2 <- li5[[2]]
    sigma2 <- update_sigma2(z,y,mu1,mu2,mu3,v1,v2)
    mu1 <- update_mu1(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    mu2 <- update_mu2(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    mu3 <- update_mu3(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    c1track[[it]] <- c1
    c2track[[it]] <- c2
    c3track[[it]] <- c3
    pb$tick()
    Sys.sleep(1/100)
  }
  c1track <- c1track[2501:5000]
  c2track <- c2track[2501:5000]
  c3track <- c3track[2501:5000]
  rvec <- unlist(lapply(c1track, function(x) return(ncol(x))))
  rp <- as.numeric(names(table(rvec))[table(rvec) == max(table(rvec))])
  c1track <- c1track[which(rvec==rp)]
  c2track <- c2track[which(rvec==rp)]
  c3track <- c3track[which(rvec==rp)]
  c1p <- matrix(unlist(c1track),nrow = d[1]*rp)
  c2p <- matrix(unlist(c2track),nrow = d[2]*rp)
  c3p <- matrix(unlist(c3track),nrow = d[3]*rp)
  c1p <- matrix(rowMeans(c1p),nrow=d[1])
  c2p <- matrix(rowMeans(c2p),nrow=d[2])
  c3p <- matrix(rowMeans(c3p),nrow=d[3])
return(list(c1p,c2p,c3p))
}
ob = foreach(i=1:10,.combine=rbind,.packages=c("simFrame","progress","testarma","gtools")) %dopar% 
  {
    data <- generatedata_overlap(i)
    y <- data[[1]]
    yna <- data[[2]]
    c1 <- data[[3]]
    c2 <- data[[4]]
    c3 <- data[[5]]
    bayes_multi(y,c1,c2,c3)
  }
ob2= foreach(i=6:10,.packages=c("simFrame","progress","testarma","gtools")) %dopar% 
  {
    data <- generatedata_overlap(i)
    y <- data[[1]]
    #yna <- data[[2]]
    c1 <- data[[3]]
    c2 <- data[[4]]
    c3 <- data[[5]]
    bayes_multi_n(y,c1,c2,c3)
  }
 nob = foreach(i=1:10,.packages=c("progress","testarma","gtools")) %dopar% 
  {
    data <- generate_nonoverlap(i)
    y <- data[[1]]
    #yna <- data[[2]]
    c1 <- data[[2]]
    c2 <- data[[3]]
    c3 <- data[[4]]
    bayes_multi_n(y,c1,c2,c3)
  }

result = foreach(i=1:10,.combine=rbind,.packages=c("progress","testarma","gtools")) %dopar% 
  {
    data <- generate_nonoverlap(i)
    #y <- data[[1]]
    #yna <- data[[2]]
    c1 <- data[[2]]
    c2 <- data[[3]]
    c3 <- data[[4]]
    c1b <- nob[[i]][[1]]
    c2b <- nob[[i]][[2]]
    c3b <- nob[[i]][[3]]
    c(min_ham(c1,c1b),min_ham(c2,c2b),min_ham(c3,c3b))
  }

result = foreach(i=1:10,.combine=rbind,.packages=c("progress","testarma","gtools")) %dopar% 
  {
    data <- generatedata_overlap(i)
    #y <- data[[1]]
    #yna <- data[[2]]
    c1 <- data[[3]]
    c2 <- data[[4]]
    c3 <- data[[5]]
    if(i<=5){
      c1na <- ob1[[i]][[1]]
      c2na <- ob1[[i]][[2]]
      c3na <- ob1[[i]][[3]]
    }
    else{
      c1na <- ob2[[i-5]][[1]]
      c2na <- ob2[[i-5]][[2]]
      c3na <- ob2[[i-5]][[3]]
    }
    if(ncol(c1na)==1){
      c1na <- cbind(c1na,rep(0,15))
      c1na <- cbind(c1na,rep(0,15))
      c2na <- cbind(c2na,rep(0,200))
      c2na <- cbind(c2na,rep(0,200))
      c3na <- cbind(c3na,rep(0,15))
      c3na <- cbind(c3na,rep(0,15))
    }
    if(ncol(c1na)==2){
      c1na <- cbind(c1na,rep(0,15))
      c2na <- cbind(c2na,rep(0,200))
      c3na <- cbind(c3na,rep(0,15))
    }
    if(ncol(c1na)>3){
      c1 <- cbind(c1,rep(0,15))
      c2 <- cbind(c2,rep(0,200))
      c3 <- cbind(c3,rep(0,15))
    }
    c(min_ham(c1,c1na),min_ham(c2,c2na),min_ham(c3,c3na))
  }
mean(result[,1]/15)
sd(result[,1]/15)
mean(result[,2]/200)
sd(result[,2]/200)
mean(result[,3]/15)
sd(result[,3]/15)
```

## Hloyd

```{r}
oh = foreach(i=1:10,.combine=rbind,.packages=c("HLloyd","simFrame","progress","reshape2")) %dopar% 
  {
    {data <- generatedata_overlap(i)
    y <- data[[1]]
    yna <- data[[2]]
    c1 <- data[[3]]
    c2 <- data[[4]]
    c3 <- data[[5]]}
    #bayes_multi(y,c1,c2,c3)
    y_tensor <- as.tensor(y)
    r <- 3
    set.seed(1)
    ## tensor method
    z.HOSC = HO.SC(y_tensor, r) # high-order initialization
    z.Lloyd.HOSC = HO.Lloyd(y_tensor, z.HOSC) # HLloyd iteration
    
    c1_ind <- data.frame("object"=1:15,"class"=z.Lloyd.HOSC[[1]],"value"=rep(1,15))
    c2_ind <- data.frame("object"=1:200,"class"=z.Lloyd.HOSC[[2]],"value"=rep(1,200))
    c3_ind <- data.frame("object"=1:15,"class"=z.Lloyd.HOSC[[3]],"value"=rep(1,15))
    c1h <- acast(c1_ind,object~class)
    c1h[which(is.na(c1h))] <- 0
    c2h <- acast(c2_ind,object~class)
    c2h[which(is.na(c2h))] <- 0
    c3h <- acast(c3_ind,object~class)
    c3h[which(is.na(c3h))] <- 0 
    c(min_ham(c1h,c1),min_ham(c2h,c2),min_ham(c3h,c3))
  }

noh = foreach(i=1:10,.combine=rbind,.packages=c("HLloyd","testarma","simFrame","progress","reshape2")) %dopar% 
  {
    data <- generate_nonoverlap(i)
    y <- data[[1]]
    #yna <- data[[2]]
    c1 <- data[[2]]
    c2 <- data[[3]]
    c3 <- data[[4]]
    #bayes_multi(y,c1,c2,c3)
    y_tensor <- as.tensor(y)
    r <- 3
    set.seed(1)
    ## tensor method
    z.HOSC = HO.SC(y_tensor, r) # high-order initialization
    z.Lloyd.HOSC = HO.Lloyd(y_tensor, z.HOSC) # HLloyd iteration
    
    c1_ind <- data.frame("object"=1:15,"class"=z.Lloyd.HOSC[[1]],"value"=rep(1,15))
    c2_ind <- data.frame("object"=1:200,"class"=z.Lloyd.HOSC[[2]],"value"=rep(1,200))
    c3_ind <- data.frame("object"=1:15,"class"=z.Lloyd.HOSC[[3]],"value"=rep(1,15))
    c1h <- acast(c1_ind,object~class)
    c1h[which(is.na(c1h))] <- 0
    c2h <- acast(c2_ind,object~class)
    c2h[which(is.na(c2h))] <- 0
    c3h <- acast(c3_ind,object~class)
    c3h[which(is.na(c3h))] <- 0 
    c(min_ham(c1h,c1),min_ham(c2h,c2),min_ham(c3h,(c3!=0)))
  }

```

## MatrixForm

```{r}

mf <- function(ym,c1,c3){
 X0 <- ym
# Initialize parameters
set.seed(41)
r = c(0.2, 0.6, 0.2)
u = rep(0, ncol(X0))
Y = matrix(0, nrow(X0), ncol(X0))
s = rgamma(ncol(X0), 1, 0.1); k1 = k2 = 5 * sqrt(s)
A = matrix(as.numeric(runif(nrow(X0)) < 0.5), nrow(X0))
z1 = rnorm(ncol(X0), 0, 10); z2 = rnorm(ncol(X0), 0, 10)
W1 = matrix(rgamma(ncol(X0), 1, 0.1), ncol(X0)); W2 = matrix(rgamma(ncol(X0), 1, 0.1), ncol(X0))
C = matrix(as.numeric(runif(ncol(X0)) < 0.5), ncol(X0)); C[C == 1] = C[C == 1] - 2 * (runif(sum(C)) < 0.5)

recordA = list(A); recordC = list(C); iter = 1; maxit = 1000

while(iter < maxit) {
  # update uniform bound and indicator in a block
  RY = updateY(X0, Y, A, C, W1, W2, z1, z2, u, k1, k2, s)
  k1 = RY$k1; k2 = RY$k2; Y = RY$Y
  # mean parameter
  u = updateu(X0, Y, s, k1, k2)
  # variance parameter
  s = updates(X0, Y, u, k1, k2)
  # latent association A
  RA = updateA(Y, A, C, W1, W2, z1, z2, r)
  A = RA$A; C = RA$C; W1 = RA$W1; W2 = RA$W2;
  # latent association C
  C = updateC(Y, A, C, W1, W2, z1, z2, r)
  # probability of indicator
  r = updater(C)
  # effect size
  W1 = updateW1(Y, A, C, W1, W2, z1, z2)
  W2 = updateW2(Y, A, C, W1, W2, z1, z2)
  # residual size
  z1 = updatez1(Y, A, C, W1, W2, z1, z2)
  z2 = updatez2(Y, A, C, W1, W2, z1, z2)
  
  recordA = c(recordA, list(A))
  recordC = c(recordC, list(C))
  
  iter = iter + 1
}

kclass <- vector()
for(i in 501:length(recordA)){
  kclass[i] <- ncol(recordA[[i]])
}
kl <- as.numeric(names(table(kclass))[which.max(table(kclass))])
Aleft <- recordA[which(kclass==kl)]
AP <- matrix(0,nrow = 15*kl,ncol = sum(na.omit(kclass==kl)))
for(t in 1:length(Aleft)){
  # kclass[i] <- ncol(c1track[[i]])
  AP[,t] <- as.vector(Aleft[[t]])
}
Appp <- as.matrix(apply(AP, 1, mean))

#plot(kclass)
Appp <- matrix(Appp,nrow = 15,ncol = kl)
A <- Appp
Cleft <- recordC[which(kclass==kl)]
CP <- matrix(0,nrow = 15*kl,ncol = sum(na.omit(kclass==kl)))
for(t in 1:length(Cleft)){
  # kclass[i] <- ncol(c1track[[i]])
  CP[,t] <- as.vector(Cleft[[t]])
}
Cppp <- as.matrix(apply(CP, 1, mean))
#plot(kclass)
Cppp <- matrix(Cppp,nrow = 15,ncol = kl)
C <- Cppp
if(ncol(A)>3){
  c1 <- cbind(c1,matrix(0,nrow = 15,ncol = ncol(A)-3))
  c3 <- cbind(c3,matrix(0,nrow = 15,ncol = ncol(A)-3))
}
if(ncol(A)<3){
  A <- cbind(A,matrix(0,nrow = 15,ncol = 3-ncol(A)))
  C <- cbind(C,matrix(0,nrow = 15,ncol = 3-ncol(A)))
}
c1_ham <- min_ham(A, c1)
#c2_ham3[repli] <- min_ham(c2, c2_ol)
c3_ham <- min_ham(C, c3) 
return(c(c1_ham,c3_ham))
}

om = foreach(i=1:10,.combine=rbind,.packages=c("simFrame","progress","MatrixForm","gtools","truncnorm")) %dopar% 
  {
    data <- generatedata_overlap(i)
    y <- data[[1]]
    y_matrix <- apply(y, c(1,3),mean)
    #yna <- data[[2]]
    c1 <- data[[3]]
    #c2 <- data[[4]]
    c3 <- data[[5]]
    mf(y_matrix,c1,c3)
  }
nom = foreach(i=1:10,.combine=rbind,.packages=c("progress","MatrixForm","gtools","truncnorm")) %dopar% 
  {
    data <- generate_nonoverlap(i)
    y <- data[[1]]
    y_matrix <- apply(y, c(1,3),mean)
    #yna <- data[[2]]
    c1 <- data[[2]]
    #c2 <- data[[3]]
    c3 <- data[[4]]
    mf(y_matrix,c1,c3)
  }


```

## MultiCluster

```{r}
y1 <- matrix(0,nrow = 15*15*200,ncol = 10)
y2 <- matrix(0,nrow = 15*15*200,ncol = 10)
for (la in 1:10) {
  data <- generatedata_overlap(la)
  y1[,la] <- as.vector(data[[1]])
  data <- generate_nonoverlap(la)
  y2[,la] <- as.vector(data[[1]])
}
cy <- matrix(0,nrow = 15,ncol = 10)
cyy <- matrix(0,nrow = 15,ncol = 10)
cz <- matrix(0,nrow = 15,ncol = 10)
czz <- matrix(0,nrow = 15,ncol = 10)
cx <- matrix(0,nrow = 200,ncol = 10)
cxx <- matrix(0,nrow = 200,ncol = 10)
for (la in 1:10) {
  cz[,la] <- read.csv(paste("z",la,".csv",sep = ""),header = FALSE)$V1
  czz[,la] <- read.csv(paste("zn",la,".csv",sep = ""),header = FALSE)$V1
  cy[,la] <- read.csv(paste("y",la,".csv",sep = ""),header = FALSE)$V1
  cyy[,la] <- read.csv(paste("yn",la,".csv",sep = ""),header = FALSE)$V1
  cx[,la] <- read.csv(paste("x",la,".csv",sep = ""),header = FALSE)$V1
  cxx[,la] <- read.csv(paste("xn",la,".csv",sep = ""),header = FALSE)$V1
}
recordo <- matrix(0,10,3)
recordn <- matrix(0,10,3)
for (la in 1:10) {
  data <- generatedata_overlap(la)
  c1 <- data[[3]]
  c2 <- data[[4]]
  c3 <- data[[5]]
  mm1 <- tomembershipmatrix(list(cx[,la]))[[1]]
  mm2 <- tomembershipmatrix(list(cz[,la]))[[1]]
  mm3 <- tomembershipmatrix(list(cy[,la]))[[1]]
  recordo[la,] <- c(min_ham(mm1,c2),min_ham(mm2,c1),min_ham(mm3,c3!=0))
  data <- generate_nonoverlap(la)
  c1 <- data[[2]]
  c2 <- data[[3]]
  c3 <- data[[4]]
  mm1 <- tomembershipmatrix(list(cxx[,la]))[[1]]
  mm2 <- tomembershipmatrix(list(czz[,la]))[[1]]
  mm3 <- tomembershipmatrix(list(cyy[,la]))[[1]]
  recordn[la,] <- c(min_ham(mm1,c2),min_ham(mm2,c1),min_ham(mm3,c3!=0))
}
```

## BMWCNA

```{r}
bayes_multi_na <- function(y,c1,c2,c3){
set.seed(1)
{
  c1track <- list()
  c2track <- list()
  c3track <- list()
  al=1;bl=3;av=1;bv=10;am=1;bm=1;sigmal=1;mub=-2
  ;sigmab=1;arho=1;brho=1;psi_1=5;psi0=20;psi1=5;as=1;bs=1;sigmamu=1;
 
  #//dimension
  d=dim(y);
  
 #//class number
  r=1;
  c1 = matrix(as.numeric(runif(d[1] * r) < 0.5), d[1], r)
  c2 = matrix(as.numeric(runif(d[2] * r) < 0.5), d[2], r)
  c3 = matrix(as.numeric(runif(d[3] * r) < 0.5), d[3], r)
  lambda1 <- matrix(rgamma(d[3]*r, al, 1/bl), d[3],r)
  lambda2 <- lambda1
  #//paramters
  mu1 <- rep(0,d[1])
  mu2 <- rep(0,d[2])
  mu3 <- rep(0,d[3])
  sigma2 <- rep(1,d[1])
  v1 <- 5*sigma2
  v2 <- v1
  #b1 <- matrix(rnorm(d[2]*d[3]),nrow = d[2],ncol = d[3])
  b1 <- matrix(-2,nrow = d[2],ncol = d[3])
  b2 <-b1
  m=3;rho=0.3;g=1;
  
  #vec gamma(3,fill::randu);
  gamma <- c(rho/2,1-rho,rho/2)
  #z <- z0
  z <- array(0,dim = d)
  z[which(is.na(y))] <- NA
}
  #//MCMC update
  pb <- progress_bar$new(format = "  complete [:bar] :percent eta: :eta",
                       total = 5000, clear = FALSE, width= 60)
  for(it in 1:5000){
    #ztrack[[it]] <- z
    
    
    z <- update_z(c1, c2, c3, lambda1, lambda2, d, z, b1, b2, v1, v2, av, bv, y, mu1, mu2, mu3, sigma2);
    v1 <- update_v1(z,y,mu1,mu2,mu3,v1,v2,d,av,bv,sigma2)
    v2 <- update_v2(z,y,mu1,mu2,mu3,v1,v2,d,av,bv,sigma2)
    li1 <- update_c1(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,gamma, m,g,rho,al,bl)
    c1 <- li1[[1]]
    c2 <- li1[[2]]
    c3 <- li1[[3]]
    lambda1 <- li1[[4]]
    lambda2 <- li1[[5]]
    r <- ncol(c1)
    c2 <- update_c2(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,rho);
    li2 <-  update_c3(c1,c2,c3,lambda1,lambda2,d,z,b1,b2,gamma,sigmal,al,bl)
    c3 <-li2[[1]]
    lambda1 <- li2[[2]]
    lambda2 <- li2[[3]]
    
    #m <- rgamma(1,am+r,bm+har(d[1]))
    #//update $\rho$
    rho <-  rbeta(1,arho+sum(c2),brho+d[2]*r-sum(c2))
    #//update $\gamma$
    probs <- c(psi_1+sum(c3==-1),psi0+sum(c3==0),psi1+sum(c3==1))
    gamma <- rdirichlet(1,probs)
    li5 <- update_bunit(d,mub,sigmab,b1,b2,c1,c2,c3,lambda1,lambda2,z)
    b1 <- li5[[1]]
    b2 <- li5[[2]]
    sigma2 <- update_sigma2(z,y,mu1,mu2,mu3,v1,v2)
    mu1 <- update_mu1(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    #mu2 <- update_mu2(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    mu3 <- update_mu3(z,y,sigmamu,sigma2,mu1,mu2,mu3)
    c1track[[it]] <- c1
    c2track[[it]] <- c2
    c3track[[it]] <- c3
    pb$tick()
    Sys.sleep(1/100)
  }
  c1track <- c1track[2501:5000]
  c2track <- c2track[2501:5000]
  c3track <- c3track[2501:5000]
  rvec <- unlist(lapply(c1track, function(x) return(ncol(x))))
  rp <- as.numeric(names(table(rvec))[table(rvec) == max(table(rvec))])
  c1track <- c1track[which(rvec==rp)]
  c2track <- c2track[which(rvec==rp)]
  c3track <- c3track[which(rvec==rp)]
  c1p <- matrix(unlist(c1track),nrow = d[1]*rp)
  c2p <- matrix(unlist(c2track),nrow = d[2]*rp)
  c3p <- matrix(unlist(c3track),nrow = d[3]*rp)
  c1p <- matrix(rowMeans(c1p),nrow=d[1])
  c2p <- matrix(rowMeans(c2p),nrow=d[2])
  c3p <- matrix(rowMeans(c3p),nrow=d[3])
return(list(c1p,c2p,c3p))
}
set.seed(3)
d <- c(15,200,15)
nac <- sample(1:(d[1]*d[2]),0.5*d[1]*d[2])
obna1 = foreach(i=6:10,.packages=c("simFrame","progress","BMWCNA","gtools")) %dopar% 
  {
    data <- generatedata_na(i,nac)
    #y <- data[[1]]
    yna <- data[[2]]
    c1 <- data[[3]]
    c2 <- data[[4]]
    c3 <- data[[5]]
    bayes_multi_na(yna,c1,c2,c3)
  }
 c1_avna <- matrix(0,15,3)
c2_avna <- matrix(0,200,3)
c3_avna <- matrix(0,15,3)
for (i in 1:10){
    data <- generatedata_na(i,nac)
    #y <- data[[1]]
    #yna <- data[[2]]
    c1 <- data[[3]]
    c2 <- data[[4]]
    c3 <- data[[5]]
    if(i<=5){
      c1na <- obna[[i]][[1]]
      c2na <- obna[[i]][[2]]
      c3na <- obna[[i]][[3]]
    }
    else{
      c1na <- obna1[[i-5]][[1]]
      c2na <- obna1[[i-5]][[2]]
      c3na <- obna1[[i-5]][[3]]
    }
    if(ncol(c1na)<3){
      c1na <- cbind(c1na,rep(0,15))
      c2na <- cbind(c2na,rep(0,200))
      c3na <- cbind(c3na,rep(0,15))
    }
    if(ncol(c1na)>3){
      del <- which.min(colSums(c1na))
      c1na <- c1na[,-del]
      c2na <- c2na[,-del]
      c3na <- c3na[,-del]
    }
    c1na = c1na[,perE(c1,c1na)]
    c2na = c2na[,perE(c2,c2na)]
    c3na = c3na[,perE(c3,c3na)]
    c1_avna = c1_avna+c1na
    c2_avna = c2_avna+c2na
    c3_avna = c3_avna+c3na
}
c1_avna <- c1_avna/10
c2_avna <- c2_avna/10
c3_avna <- c3_avna/10
```

## plot

```{r}
library(reshape2)
library(ggplot2)
pc1p = melt(t(c1_avna), varnames = c("Factor", "secondorder"), value.name = "Indicator")
pc2p = melt(t(c2_avna), varnames = c("Factor", "secondorder"), value.name = "Indicator")
pc3p = melt(t(c3_avna), varnames = c("Factor", "secondorder"), value.name = "Indicator")
```

```{r}
ggplot2::ggplot(pc1p, aes(x = secondorder, y = Factor)) + geom_tile(aes(fill = Indicator), color = "black") +
  scale_fill_gradient(low = "black", high = "green") + theme(legend.position = "none") +
  scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + labs(x = "", y = "")
```

```{r}
ggplot2::ggplot(pc2p, aes(x = secondorder, y = Factor)) + geom_tile(aes(fill = Indicator), color = "black") +
  scale_fill_gradient(low = "black", high = "green") + theme(legend.position = "none") +
  scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + labs(x = "", y = "")
```

```{r}
ggplot2::ggplot(pc3p, aes(x = secondorder, y = Factor)) + geom_tile(aes(fill = Indicator), color = "black") +
  scale_fill_gradientn(colors = c("red", "black", "green"), breaks = c(-1, 0, 1)) + theme(legend.position = "none") +
  scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) + labs(x = "", y = "")
```
